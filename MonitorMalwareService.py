import win32serviceutil
import win32service
import win32event
import servicemanager
import sys
import time
import os
from datetime import datetime, timedelta
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scapy.all import sniff, IP, TCP, UDP, wrpcap,DNS, DNSQR, Raw
from scapy.main import load_layer
load_layer("tls")
from scapy.layers.tls.record import TLS

from modules.analyzer import Analyzer
import psutil
import sqlite3
import shutil
import wmi  # For process lifecycle monitoring
import trio
import whois
import dns.resolver
from collections import defaultdict
import re
import subprocess
from modules.blacklist import Blacklist
from modules.watchlist import Watchlist


current_dir = os.path.dirname(os.path.abspath(__file__))
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

class MalwareFileHandler(FileSystemEventHandler):
    """Activate when a file is created or modified in the monitored directory."""
    def __init__(self, log_func, analyzer):
        self.log_func = log_func
        self.analyzer = analyzer
    
    def on_created(self, event):
        """
        Handle file creation events. 
        """
        if not event.is_directory:    
            trio.run(self.analyzer.analyze_file, event.src_path)

    def on_modified(self, event):
        """
        Handle file modification events.
        """
        if not event.is_directory:
            trio.run(self.analyzer.analyze_file, event.src_path)


class MonitorMalwareService(win32serviceutil.ServiceFramework):
    """Windows service for monitoring macro malware in Office files."""
    
    _svc_name_ = "A_Monitor_Macro_Malware_Service"
    _svc_display_name_ = "A Monitor Macro Malware Service"
    _svc_description_ = "Monitors macro-based malware in Microsoft Office files"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        
        # Script directory for logs and Sysinternals
        
        self.log_dir = os.path.join(current_dir, f"Logs/Logs_{timestamp}")
        os.makedirs(self.log_dir, exist_ok=True)

        self.log_file = os.path.join(self.log_dir, f"logs_")
        self.log_sniffer_file = os.path.join(self.log_dir, f"logsniffer_{timestamp}.txt")
        self.pcap_file = os.path.join(self.log_dir, f"network_{timestamp}.pcap")
      
        # Directory to monitor (limited to user Documents for performance)
        self.monitor_dir = "C:\\"


        self.blacklist = Blacklist(self.log_dir, self._log)
        self.watchlist = Watchlist(self.log_dir, self._log)


        # Initialize Sysinternals and modules
        self.sysinternals_path = os.path.join(current_dir, 'SYSINTERNAL')
        self.analyzer = Analyzer(self.sysinternals_path, self.log_dir, self.blacklist, self.watchlist, self._log)

        # Initialize file system observer
        self.observer = Observer()
        self.event_handler = MalwareFileHandler(self._log, self.analyzer)
        self.observer.schedule(self.event_handler, path=self.monitor_dir, recursive=True)

        # Network sniffing thread
        self.sniffing_thread = None
        self.packets = []
        # WMI for process lifecycle monitoring
        self.wmi_client = wmi.WMI()

        self.in_monitor_keywords = {
            'suspicious': [],
            'ioc': [],
            'vba_obfuscated': [],
            'autoexec': []
        }

        self.point_values = {
            'suspicious': 10,
            'ioc': 30,
            'vba_obfuscated': 20,
            'autoexec': 20
        }

        self.bl_port = {}
        self.bl_ip = {}

    def SvcStop(self):
        """Stop the service, observer, and network sniffing."""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.observer.stop()
        self.observer.join()

        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        self._log("Service stopped", "INFO")
        
        # Save the blacklist and watchlist to JSON files
        
        self.blacklist.save_to_json(force=True)
        

        # Save captured packets to PCAP file
        try:
            if self.packets:
                wrpcap(self.pcap_file, self.packets)
                self._log(f"Network packets saved to {self.pcap_file}", "INFO")
        except Exception as e:
            self._log(f"Failed to save PCAP file: {str(e)}", "ERROR")
        
        if self.sniffing_thread:
            self.sniffing_thread.join()

        if self.process_monitor_thread:
            self.process_monitor_thread.join()
        

    def SvcDoRun(self):
        """Start the service, Sysmon, observer, and network sniffing."""
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,
                            servicemanager.PYS_SERVICE_STARTED,
                            (self._svc_name_, ''))
        self._log("Service started", "INFO")
        # Start file system observer
        self.observer.start()

        # Start network sniffing
        self.sniffing_thread = threading.Thread(target=self.sniff_network, daemon=True)
        self.sniffing_thread.start()
        
        # Start process lifecycle monitoring
        self.process_monitor_thread = threading.Thread(target=self.monitor_process_lifecycle, daemon=True)
        self.process_monitor_thread.start()
        # Run infinite loop to keep the service running
        self.main()

    def _log(self, message, severity="INFO", is_ignored=False): 
        """Log messages to files by severity/type.
        Args:
            message (str): The message to log.
            severity (str): The severity level of the message (e.g., "INFO", "ERROR", "DEBUG").
            is_ignored (bool): Flag to ignore print to separate file, only log to FULL log.
        
        RULES:
            INFO - normal operation + DEBUG
            WARN - if suspicious is detected
            CRITICAL - if it is deemed as a threat
            ALERT - what action was taken to a CRITICAL threat
            ERROR - if there is an error
            IGNORED - if the file, ip, process, is ignored 
        """
        tag = f"[{severity}]"
        log_message = f"{tag} {message}"
        try:
            if "IGNORED" in tag:
                return

            with open(self.log_file + "FULL.log", "a") as f:
                f.write(f"[{time.ctime()}] {log_message}\n")

            if not is_ignored :
                with open(self.log_file + f"_{severity}.log", "a") as f:
                    f.write(f"[{time.ctime()}] {log_message}\n")

        except Exception as e:
            servicemanager.LogErrorMsg(f"[_log] Logging failed: {str(e)}")

    def scan_directory(self):
        """Scan the monitored directory for existing Office files and analyze them.

        """
        self._log(f"Scanning directory {self.monitor_dir} for Office files", "INFO")
        total = 0
        for root, _, files in os.walk(self.monitor_dir):
            for file in files:
                file_path = os.path.join(root, file)
                trio.run(self.analyzer.analyze_file,file_path)
                time.sleep(0.1) # Prevent overload
        self._log(f"Scanning directory {self.monitor_dir} completed", "INFO")

    def monitor_process_lifecycle(self):
        """Monitor process creation and termination using WMI."""
        process_watcher = self.wmi_client.Win32_Process.watch_for("creation")
        while self.is_running:
            time.sleep(.1)  # Adjust the sleep time as needed
            try:
                new_process = process_watcher()
                proc_name = new_process.Name.lower()
                if proc_name in self.analyzer.suspicious_process: #or proc_name in list(self.analyzer.watchlist.summaries['file_name_to_hash'].keys()):
                    self._log(f"Suspicious process created: {proc_name} (PID: {new_process.ProcessId})", "WARN")
                    parent_pid = new_process.ParentProcessId
                    parent_proc = psutil.Process(parent_pid)

                    res = self.analyzer.analyze_process(new_process.ProcessId)
                    is_suspicious, result = res
                    if result.get('is_suspicious', False) or result.get('threat_score', 0) >= 50 or result.get('is_dangerous', False):
                        self._log(f"Suspicious process detected: {proc_name} (PID: {new_process.ProcessId})", "CRITICAL")
                    else:
                        self._log(f"Process {proc_name} (PID: {new_process.ProcessId}) deemed safe", "INFO")
                        
            except Exception as e:
                self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")

    def scan_processes(self):
        """Monitor running processes for suspicious activities, including background processes and common Windows apps."""
        self._log(f"Scanning processes {self.monitor_dir} for suspicious", "INFO")
        total = 0
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'status']):
            is_suspicious , _= trio.run(self.analyzer.analyze_process,proc.pid)
            if is_suspicious:
                total +=1
        self._log(f"Scanning processes completed. No. of suspicious found {total}", "INFO")

    def sniff_network(self):
        """Sniff network packets for Office-related suspicious activities."""
        try:
            self._log("Starting network packet sniffing...", "INFO")
            sniff(prn=self.analyzer.analyze_packet, filter="tcp or udp", store=False, timeout=3600)
        except Exception as e:
            self._log(f"Network sniffing error: {str(e)}", "ERROR")

    def main(self):
        """Main service loop for keep running the service."""
        time.sleep(2) # Wait for the service to stabilize
        self._log(f"Begin scanning every file in {self.monitor_dir}. This will happen only ONCE...", "INFO")
        threading.Thread(target=self.scan_directory).start()
        self._log(f"Begin scanning every process in {self.monitor_dir}. This will happen only ONCE...", "INFO")
        threading.Thread(target=self.scan_processes).start()
        while self.is_running:
            try:
                time.sleep(5)
            except Exception as e:
                self._log(f"Error in main loop: {str(e)}", "ERROR")
        self.observer.stop()
        self.observer.join()

if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(MonitorMalwareService)
            servicemanager.StartServiceCtrlDispatcher()
        else:
            win32serviceutil.HandleCommandLine(MonitorMalwareService)
    except Exception as e:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        error_log = os.path.join(script_dir, f"error_{timestamp}.txt")
        with open(error_log, "a") as f:
            f.write(f"[{time.ctime()}] Error: {str(e)}\n")