import win32serviceutil
import win32service
import win32event
import servicemanager
import sys
import time
import os
from datetime import datetime, timedelta
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scapy.all import sniff, IP, TCP, UDP, wrpcap,DNS, DNSQR, Raw
from scapy.main import load_layer
load_layer("tls")
from scapy.layers.tls.record import TLS
from pathlib import Path

from modules.analyzer import Analyzer
import psutil
import sqlite3
import shutil
import wmi  # For process lifecycle monitoring
import trio
import whois
import dns.resolver
from collections import defaultdict
import re
import subprocess
import queue
from modules.blacklist import Blacklist
from modules.watchlist import Watchlist
from concurrent.futures import ThreadPoolExecutor

current_dir = os.path.dirname(os.path.abspath(__file__))
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

class MalwareFileHandler(FileSystemEventHandler):
    """Activate when a file is created or modified in the monitored directory."""
    def __init__(self, log_func, analyzer):
        self.log_func = log_func
        self.analyzer = analyzer
    
    async def on_created(self, event):
        """
        Handle file creation events. 
        """
        if not event.is_directory:
            await self.analyzer.analyze_file(event.src_path)

    async def on_modified(self, event):
        """
        Handle file modification events.
        """
        if not event.is_directory:
            await self.analyzer.analyze_file(event.src_path)


class MonitorMalwareService(win32serviceutil.ServiceFramework):
    """Windows service for monitoring macro malware in Office files."""
    
    _svc_name_ = "A_Monitor_Macro_Malware_Service"
    _svc_display_name_ = "A Monitor Macro Malware Service"
    _svc_description_ = "Monitors macro-based malware in Microsoft Office files"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        
        # Script directory for logs and Sysinternals
        
        self.log_dir = os.path.join(current_dir, f"Logs/Logs_{timestamp}")
        os.makedirs(self.log_dir, exist_ok=True)

        self.log_file = os.path.join(self.log_dir, f"logs_")
        self.log_sniffer_file = os.path.join(self.log_dir, f"logsniffer_{timestamp}.txt")
        self.pcap_file = os.path.join(self.log_dir, f"network_{timestamp}.pcap")
      
        # Directory to monitor (limited to user Documents for performance)
        self.monitor_dir = "C:\\"


        self.blacklist = Blacklist(self.log_dir, self._log)
        self.watchlist = Watchlist(self.log_dir, self._log)


        # Initialize Sysinternals and modules
        self.sysinternals_path = os.path.join(current_dir, 'SYSINTERNAL')
        self.analyzer = Analyzer(self.sysinternals_path, self.log_dir, self.blacklist, self.watchlist, self._log)

        # Initialize file system observer
        self.observer = Observer()
        self.event_handler = MalwareFileHandler(self._log, self.analyzer)
        self.observer.schedule(self.event_handler, path=self.monitor_dir, recursive=True)

        # Network sniffing thread
        self.sniffing_thread = None
         
        self.packets = []
        # WMI for process lifecycle monitoring
        self.wmi_client = wmi.WMI()

        self.log_queue = queue.Queue()
        self.last_flush = 0

    def SvcStop(self):
        """Stop the service, observer, and network sniffing."""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.observer.stop()
        self.observer.join()

        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        self._log("Service stopped", "INFO", force=True)
        
        # Save the blacklist and watchlist to JSON files
        self.blacklist.save_to_json(force=True)
        self.watchlist.save_to_json(force=True)

        # Save captured packets to PCAP file
        try:
            if self.packets:
                wrpcap(self.pcap_file, self.packets)
                self._log(f"Network packets saved to {self.pcap_file}", "INFO")
        except Exception as e:
            self._log(f"Failed to save PCAP file: {str(e)}", "ERROR")
        
        if self.sniffing_thread:
            self.sniffing_thread.join()

        if self.process_monitor_thread:
            self.process_monitor_thread.join()

     
        

    def SvcDoRun(self):
        """Start the service, Sysmon, observer, and network sniffing."""
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,
                            servicemanager.PYS_SERVICE_STARTED,
                            (self._svc_name_, ''))

        self._log("Service started", "INFO")
        # Start file system observer
        self.observer.start()

        # Start network sniffing
        self.sniffing_thread = threading.Thread(target=self.sniff_network, daemon=True)
        self.sniffing_thread.start()
        
        # Start process lifecycle monitoring
        self.process_monitor_thread = threading.Thread(target=self.monitor_process_lifecycle, daemon=True)
        self.process_monitor_thread.start()
        # Run infinite loop to keep the service running
        self.main()
        self.observer.stop()
        self.observer.join()
        self.last_flush = 0

    def main(self):
        self.scan_directory()
        self.scan_processes()
        while self.is_running:
            time.sleep(5)

    def _log(self, message, severity="INFO", force = False):

        """Log messages to the log file and queue for later processing."""
        if severity in ["BM"]:
            return
        tag = f"[{severity}]"
        log_message = f"{tag} {message}"
        try:
            self.log_queue.put((log_message, severity, time.ctime()))
            if self.log_queue.qsize() >= 10 or time.time() - self.last_flush > 5 or force:
                while not self.log_queue.empty():
                    msg, sev, timestamp = self.log_queue.get()

                    with open(self.log_file + "FULL.log", "a") as f:
                        f.write(f"[{timestamp}] {msg}\n")

                    with open(self.log_file + f"_{sev}.log", "a") as f:
                        f.write(f"[{timestamp}] {msg}\n")

                self.last_flush = time.time()
        except Exception as e:
            servicemanager.LogErrorMsg(f"[_log] Logging failed: {str(e)}")

    def scan_directory(self):
        """Scan the monitored directory for existing Office files and analyze them.

        """
        self._log(f"Scanning directory {self.monitor_dir} for Office files", "INFO")
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = []
            excluded_folders = set(self.blacklist.exclusions.get('folders', [])) 
            excluded_folders_name = set(self.blacklist.exclusions.get('folders_name', []))
            # Traverse the directory tree
            for root, dirs, files in os.walk(monitor_dir, topdown=True):
                # Normalize the current root path
                norm_root = os.path.normpath(root)

                # Check if the current root should be excluded
                if (any(norm_root.startswith(excluded) for excluded in excluded_folders) or
                    os.path.basename(norm_root) in excluded_folders_name):
                    self._log(f"Skipping excluded directory: {norm_root}","WARN")
                    dirs[:] = []  # Prevent traversing into subdirectories
                    continue  # Skip adding this root

                # If not excluded, scan
                for file in files:
                    file_path = os.path.join(str(root_path),file)
                    futures.append(executor.submit(trio.run, self.analyzer.analyze_file, file_path))
                # Filter out subdirectories whose names are in excluded_folders_name
                dirs[:] = [d for d in dirs if d not in excluded_folders_name]

            for future in futures:
                future.result()

    def monitor_process_lifecycle(self):
        """Monitor process creation and termination using WMI."""
        process_watcher = self.wmi_client.Win32_Process.watch_for("creation")
        while self.is_running:
            time.sleep(.5)  # Adjust the sleep time as needed
            try:
                new_process = process_watcher()
                proc_name = new_process.Name.lower()
                if proc_name in self.analyzer.suspicious_process: #or proc_name in list(self.analyzer.watchlist.summaries['file_name_to_hash'].keys()):
                    self._log(f"Suspicious process created: {proc_name} (PID: {new_process.ProcessId})", "WARN")
                    parent_pid = new_process.ParentProcessId
                    parent_proc = psutil.Process(parent_pid)

                    res = self.analyzer.analyze_process(new_process.ProcessId)
                    is_suspicious, result = res
                    if result.get('is_suspicious', False) or result.get('threat_score', 0) >= 50 or result.get('is_dangerous', False):
                        self._log(f"Suspicious process detected: {proc_name} (PID: {new_process.ProcessId})", "CRITICAL")
                    else:
                        self._log(f"Process {proc_name} (PID: {new_process.ProcessId}) deemed safe", "INFO")
                        
            except Exception as e:
                self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")

    def scan_processes(self):
        """Monitor running processes for suspicious activities, including background processes and common Windows apps."""
        self._log(f"Scanning processes {self.monitor_dir} for suspicious", "INFO")
        total = 0
        proc_cache = list(psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'status']))
        for proc in proc_cache:
           is_suspicious, _ = trio.run(self.analyzer.analyze_process, proc.pid)
           if is_suspicious:
               total += 1
        self._log(f"Scanning processes completed. No. of suspicious found {total}", "INFO")

    def sniff_network(self):
        """Sniff network packets for Office-related suspicious activities."""
        try:
            self._log("Starting network packet sniffing...", "INFO")
            sniff(prn=self.analyzer.analyze_packet, filter="tcp or udp", store=False, timeout=7200)

        except Exception as e:
            self._log(f"Network sniffing error: {str(e)}", "ERROR")

 

if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(MonitorMalwareService)
            servicemanager.StartServiceCtrlDispatcher()
        else:
            win32serviceutil.HandleCommandLine(MonitorMalwareService)
    except Exception as e:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        error_log = os.path.join(script_dir, f"error_{timestamp}.txt")
        with open(error_log, "a") as f:
            f.write(f"[{time.ctime()}] Error: {str(e)}\n")