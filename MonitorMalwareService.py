import win32serviceutil
import win32service
import win32event
import servicemanager
import sys
import time
import os
from datetime import datetime, timedelta
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scapy.all import sniff, IP, TCP, UDP, wrpcap,DNS, DNSQR, Raw
from scapy.main import load_layer
load_layer("tls")
from scapy.layers.tls.record import TLS

from modules.analyzer import Analyzer
import psutil
import sqlite3
import shutil
import wmi  # For process lifecycle monitoring
import trio
import whois
import dns.resolver
from collections import defaultdict
import re
import subprocess



current_dir = os.path.dirname(os.path.abspath(__file__))
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

class MalwareFileHandler(FileSystemEventHandler):
    """Activate when a file is created or modified in the monitored directory."""
    def __init__(self, log_func, macro_analyzer):
        self.log_func = log_func
        self.macro_analyzer = macro_analyzer

    def on_created(self, event):
        """
        Handle file creation events. 
        If the file is an Office file, analyze it.
        """
        if not event.is_directory:    
            if not event.src_path.startswith(current_dir):
                if self.macro_analyzer.is_office_file(event.src_path):
                    trio.run(self.macro_analyzer.main_analyze_r, event.src_path)

    def on_modified(self, event):
        if not event.is_directory:
            if not event.src_path.startswith(current_dir):
                if self.macro_analyzer.is_office_file(event.src_path):
                    trio.run(self.macro_analyzer.main_analyze_r, event.src_path)


class MonitorMalwareService(win32serviceutil.ServiceFramework):
    """Windows service for monitoring macro malware in Office files."""
    
    _svc_name_ = "A_Monitor_Macro_Malware_Service"
    _svc_display_name_ = "A Monitor Macro Malware Service"
    _svc_description_ = "Monitors macro-based malware in Microsoft Office files"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        
        # Script directory for logs and Sysinternals
        
        self.log_dir = os.path.join(current_dir, f"Logs/Logs_{timestamp}")
        os.makedirs(self.log_dir, exist_ok=True)

        self.log_file = os.path.join(self.log_dir, f"logs_")
        self.log_sniffer_file = os.path.join(self.log_dir, f"logsniffer_{timestamp}.txt")
        self.pcap_file = os.path.join(self.log_dir, f"network_{timestamp}.pcap")
      
        # Directory to monitor (limited to user Documents for performance)
        self.monitor_dir = "C:\\"
        
        # Initialize Sysinternals and modules
        self.sysinternals_path = os.path.join(current_dir, 'SYSINTERNAL')
        self.macro_analyzer = Analyzer(self.sysinternals_path, self._log, self.log_dir)

        # Initialize file system observer
        self.observer = Observer()
        self.event_handler = MalwareFileHandler(self._log, self.macro_analyzer)
        self.observer.schedule(self.event_handler, path=self.monitor_dir, recursive=True)

        # Network sniffing thread
        self.sniffing_thread = None
        self.packets = []
        
        # WMI for process lifecycle monitoring
        self.wmi_client = wmi.WMI()

        self.in_monitor_keywords = {
            'suspicious': [],
            'ioc': [],
            'vba_obfuscated': [],
            'autoexec': []
        }

        self.point_values = {
            'suspicious': 10,
            'ioc': 30,
            'vba_obfuscated': 20,
            'autoexec': 20
        }

        self.bl_port = {}
        self.bl_ip = {}

    def SvcStop(self):
        """Stop the service, observer, and network sniffing."""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.observer.stop()
        self.observer.join()

        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        self._log("Service stopped", "INFO")
        
        # Save captured packets to PCAP file
        try:
            if self.packets:
                wrpcap(self.pcap_file, self.packets)
                self._log(f"Network packets saved to {self.pcap_file}", "INFO")
        except Exception as e:
            self._log(f"Failed to save PCAP file: {str(e)}", "ERROR")
        
        if self.sniffing_thread:
            self.sniffing_thread.join()

        if self.process_monitor_thread:
            self.process_monitor_thread.join()
        

    def SvcDoRun(self):
        """Start the service, Sysmon, observer, and network sniffing."""
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,
                            servicemanager.PYS_SERVICE_STARTED,
                            (self._svc_name_, ''))
        self._log("Service started", "INFO")
        
        # Start file system observer
        self.observer.start()

        # Start network sniffing
        self.sniffing_thread = threading.Thread(target=self.sniff_network, daemon=True)
        self.sniffing_thread.start()
        
        # Start process lifecycle monitoring
        self.process_monitor_thread = threading.Thread(target=self.monitor_process_lifecycle, daemon=True)
        self.process_monitor_thread.start()

        self.scan_directory()
        # Run infinite loop to keep the service running
        self.main()
       

    def _log(self, message, severity="INFO", is_ignored=False): 
        """Log messages to files by severity/type.
        Args:
            message (str): The message to log.
            severity (str): The severity level of the message (e.g., "INFO", "ERROR", "DEBUG").
            is_ignored (bool): Flag to ignore print to separate file, only log to FULL log.
        
        RULES:
            INFO - normal operation + DEBUG
            WARN - if suspicious is detected
            CRITICAL - if it is deemed as a threat
            ALERT - what action was taken to a CRITICAL threat
            ERROR - if there is an error
            IGNORED - if the file, ip, process, is ignored 
        """
        tag = f"[{severity}]"
        log_message = f"{tag} {message}"
        try:
            with open(self.log_file + "FULL.log", "a") as f:
                f.write(f"[{time.ctime()}] {log_message}\n")

            if not is_ignored:
                with open(self.log_file + f"_{severity}.log", "a") as f:
                    f.write(f"[{time.ctime()}] {log_message}\n")

        except Exception as e:
            servicemanager.LogErrorMsg(f"[_log] Logging failed: {str(e)}")

    def scan_directory(self):
        """Scan the monitored directory for existing Office files and analyze them.

        """
        self._log(f"Scanning directory {self.monitor_dir} for Office files", "INFO")

        for root, _, files in os.walk(self.monitor_dir):
            for file in files:
                file_path = os.path.join(root, file)
                trio.run(self.macro_analyzer.main_analyze_r,file_path)
                time.sleep(0.1)

    def combine_unique_lists_ordered(self,list1, list2):
        seen = set()
        result = []
        for item in list1 + list2:
            if item not in seen:
                seen.add(item)
                result.append(item)
        return result

    def analyse_keywords(self):
        analysis = {
                'executables': [],
                'dlls': [],
                'commands': [],
                'ip_addresses': [],
                'urls': [],
                'other_iocs': [],
            }
        # Regular expressions and command keywords
        ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
        url_pattern = re.compile(r'\bhttps?://[\w\.-]+\b')
        exe_extensions = '|'.join([re.escape(ext) for ext in self.macro_analyzer.exe_extensions])
        exe_pattern = re.compile(r'\b\w+\.(?:' + exe_extensions + r')\b', re.IGNORECASE)
        dll_pattern = re.compile(r'\b\w+\.dll\b', re.IGNORECASE)
        commands_keywords = self.macro_analyzer.commands_keywords

        # Analyze keywords in each category
        for key in self.in_monitor_keywords:
            for keyword, description in self.in_monitor_keywords[key]:
                # Categorize based on keyword content (priority order)
                if key == 'ioc':
                    if ip_pattern.search(keyword):
                        analysis['ip_addresses'].append(keyword)
                    elif url_pattern.search(keyword):
                        analysis['urls'].append(keyword)
                    elif exe_pattern.search(keyword):
                        analysis['executables'].append(keyword)
                    elif dll_pattern.search(keyword):
                        analysis['dlls'].append(keyword)
                    elif keyword.lower() in commands_keywords:
                        analysis['commands'].append(keyword)
                    else:
                        analysis['other_iocs'].append(keyword)
        
        # make changes to current list
        sus_dll = self.combine_unique_lists_ordered(self.macro_analyzer.suspicious_dlls, analysis['dlls'])
        self.macro_analyzer.suspicious_dlls = sus_dll
        
        sus_process = self.combine_unique_lists_ordered(self.macro_analyzer.suspicious_process , analysis['executables'])
        self.macro_analyzer.suspicious_process = sus_process

        sus_ip = self.combine_unique_lists_ordered(self.macro_analyzer.suspicious_ip, analysis['ip_addresses'])
        self.macro_analyzer.suspicious_ip = sus_ip

        sus_cmd = self.combine_unique_lists_ordered(self.macro_analyzer.commands_keywords, analysis['commands'])
        self.macro_analyzer.commands_keywords = sus_cmd


    async def monitor_process_lifecycle(self):
        """Monitor process creation and termination using WMI."""
        process_watcher = self.wmi_client.Win32_Process.watch_for("creation")
        while self.is_running:
            time.sleep(.1)  # Adjust the sleep time as needed
            try:
                new_process = process_watcher()
                proc_name = new_process.Name.lower()
                if proc_name in self.macro_analyzer.suspicious_process:
                    self._log(f"Suspicious process created: {proc_name} (PID: {new_process.ProcessId})", "WARN")
                    parent_pid = new_process.ParentProcessId
                    parent_proc = psutil.Process(parent_pid)
                    if parent_proc.name().lower() in self.macro_analyzer.office_processes:
                        result = await self.macro_analyzer.analyze_process(new_process.ProcessId)
                        if result.get('is_suspicious', False) or result.get('threat_score', 0) >= 50 or result.get('is_dangerous', False):
                            self._log(f"Suspicious process detected: {proc_name} (PID: {new_process.ProcessId})", "CRITICAL")
                        else:
                            self._log(f"Process {proc_name} (PID: {new_process.ProcessId}) deemed safe", "INFO")
            except Exception as e:
                self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")

    def monitor_processes(self):
        """Monitor running processes for suspicious activities, including background processes and common Windows apps."""

        for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'status']):
            try:
                proc_info = proc.info
                proc_name = proc_info['name'].lower()
                pid = proc_info['pid']
                
                # Check if process is suspicious or a common Windows process
                is_suspicious = proc_name in self.macro_analyzer.suspicious_process or proc_name in self.macro_analyzer.suspicious_process
                if is_suspicious:
                    cmdline = ' '.join(proc_info['cmdline']) if proc_info['cmdline'] else ''

                    # Check exclusions
                    is_excluded = False
                    
                    # Check process name exclusion
                    if proc_name in self.macro_analyzer.exclusions.get('processes', []):
                        #self._log(f"Skipping excluded process: {proc_name} (PID: {pid})", "DEBUG")
                        continue
                    
                    # Check folder exclusion
                    exe_path = proc.exe()
                    if any(exe_path.lower().startswith(folder.lower()) for folder in self.macro_analyzer.exclusions.get('folders', [])):
                        #self._log(f"Skipping process in excluded folder: {exe_path} (PID: {pid})", "DEBUG")
                        continue
                    
                    # Check command-line pattern exclusion
                    for pattern in self.macro_analyzer.command_pattern_regexes:
                        if pattern.search(cmdline):
                            #self._log(f"Skipping process with excluded command pattern: {cmdline} (PID: {pid})", "DEBUG")
                            is_excluded = True
                            break
                    if is_excluded:
                        continue

                    # Check if process is running in the background
                    is_background = False
               
                    try:
                        # Check parent process
                        parent = proc.parent()
                        parent_name = parent.name().lower() if parent else ''
                        if parent_name in ['systemd', 'init', 'bash', 'zsh', 'cmd.exe', 'explorer.exe']:
                            is_background = True
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        pass

                    # Check parent process (e.g., spawned by Office app)
                    parent = proc.parent()
                    parent_name = parent.name().lower() if parent else ''
                    if parent_name in self.macro_analyzer.office_processes:
                        self._log(f"Suspicious process {proc_name} (PID: {pid}) spawned by Office app {parent_name}", "CRITICAL")

                    # Handle suspicious processes
                    if proc_name in self.macro_analyzer.suspicious_process:
                        # Check for suspicious command-line arguments
                        if any(arg in proc_info['cmdline'] for arg in self.macro_analyzer.suspicious_cmd_args):
                            self._log(f"Suspicious command-line arguments detected: {cmdline} (PID: {pid})", "CRITICAL")

                            # # Terminate process and export analysis results
                            # self.threat_response.terminate_process(pid)
                            # self.threat_response.export_analysis_results(exe_path, {"cmdline": cmdline})
                        
                        # Log if running in background
                        if is_background:
                            self._log(f"Suspicious process {proc_name} (PID: {pid}) running in background", "CRITICAL")
                            
                    # Handle common Windows processes
                    elif proc_name in self.macro_analyzer.suspicious_process:
                        # Flag if spawned by Office app
                        if parent_name in self.macro_analyzer.office_processes:
                            self._log(f"Common process {proc_name} (PID: {pid}) spawned by Office app {parent_name}", "WARNING")
                        # Flag if running in background with suspicious command-line
                        if is_background and proc_info['cmdline']:
                            if len(proc_info['cmdline']) > 1:  # More than just the executable
                                self._log(f"Common process {proc_name} (PID: {pid}) running in background with args: {cmdline}", "WARNING")
                                

                    # Monitor network connections
                    try:
                        connections = proc.connections(kind='inet')
                        for conn in connections:
                            if conn.raddr:
                                self._log(f"Process {proc_name} (PID: {pid}) connected to "
                                        f"{conn.raddr.ip}:{conn.raddr.port}", 
                                        "CRITICAL" if proc_name in self.macro_analyzer.suspicious_process else "CRITICAL")
                                if conn.raddr.ip in self.macro_analyzer.suspicious_ip:
                                    self._log(f"Suspicious IP {conn.raddr.ip} detected for process {proc_name} (PID: {pid})", "CRITICAL")
                                    # self.threat_response.block_ip(conn.raddr.ip)
                                    # self.threat_response.terminate_process(pid)

                    except (psutil.AccessDenied, psutil.NoSuchProcess):
                        #self._log(f"Error accessing connections for {proc_name} (PID: {pid})", "DEBUG")
                        pass

            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                #self._log(f"Error accessing process {pid}: {str(e)}", "DEBUG")
                continue

    def sniff_network(self):
        """Sniff network packets for Office-related suspicious activities."""
        try:
            self._log("Starting network packet sniffing...", "INFO")
            sniff(prn=self.packet_callback, filter="tcp or udp", store=False, timeout=3600)
        except Exception as e:
            self._log(f"Network sniffing error: {str(e)}", "ERROR")

    def packet_callback(self, packet):
        """Process network packets, logging suspicious Office-related traffic."""
        try:
            self.packets.append(packet)
            if IP in packet:
                src_ip = packet[IP].src
                dst_ip = packet[IP].dst
                proto = "TCP" if TCP in packet else "UDP" if UDP in packet else "Unknown"
                src_port = packet[TCP].sport if TCP in packet else packet[UDP].sport if UDP in packet else 0
                dst_port = packet[TCP].dport if TCP in packet else packet[UDP].dport if UDP in packet else 0
                if packet.haslayer("Raw"):
                    payload = packet["Raw"].load.decode(errors='ignore')
                    if any(x in payload.lower() for x in ["get", "post", "user-agent"]) and self._is_encoded_payload(payload):     
                        self._log(f"Network: {proto} {src_ip}:{src_port} -> {dst_ip}:{dst_port}", "WARN")
                        self._log(f"Potential C2 communication detected: {payload} - {self._is_encoded_payload(payload)}...", "CRITICAL")
                        if src_ip not in self.macro_analyzer.exclusions.get('ips', []):
                            # self.threat_response.block_ip(src_ip)
                            self._log(f"Blocked IP {src_ip}", "ALERT")
                        else:
                            # self.threat_response.block_ip(dst_ip)
                            self._log(f"Blocked IP {dst_ip}", "ALERT")

        except Exception as e:
            self._log(f"Packet processing error: {str(e)}", "ERROR")



    def _is_encoded_payload(self, payload):
        """Check if payload appears encoded or encrypted."""
        # High proportion of non-printable characters
        non_printable = sum(1 for c in payload if ord(c) < 32 or ord(c) > 126)
        if non_printable > 6:
            return True
        # Check for common encoding patterns (e.g., base64)
        if re.search(r'^[A-Za-z0-9+/=]+$', payload):
            return True
  
        return False

    def main(self):
        """Main service loop for keep running the service."""
        while self.is_running:
            try:
                self.monitor_processes()
                #trio.run(self.scan_directory)
                time.sleep(5)
            except Exception as e:
                self._log(f"Error in main loop: {str(e)}", "ERROR")
        self.observer.stop()
        self.observer.join()

if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(MonitorMalwareService)
            servicemanager.StartServiceCtrlDispatcher()
        else:
            win32serviceutil.HandleCommandLine(MonitorMalwareService)
    except Exception as e:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        error_log = os.path.join(script_dir, f"error_{timestamp}.txt")
        with open(error_log, "a") as f:
            f.write(f"[{time.ctime()}] Error: {str(e)}\n")