import win32serviceutil
import win32service
import win32event
import servicemanager
import sys
import time
import os
from datetime import datetime
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scapy.all import sniff, wrpcap
from scapy.main import load_layer
load_layer("tls")

from modules.analyzer import Analyzer
import psutil
import wmi  # For process lifecycle monitoring
import trio
import queue
import logging
from logging import Filter, FileHandler
from modules.blacklist import Blacklist
from modules.watchlist import Watchlist
import traceback
import pythoncom

current_dir = os.path.dirname(os.path.abspath(__file__))
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
# Custom filter for severity-specific log files
class SeverityFilter(Filter):
    def __init__(self, severity):
        super().__init__()
        self.severity = severity

    def filter(self, record):
        return record.levelname == self.severity

class MalwareFileHandler(FileSystemEventHandler):
    """Activate when a file is created or modified in the monitored directory."""
    def __init__(self, log_func, exclusions, service):
        self._log = log_func
        self.exclusions_folder = exclusions.get('folders', [])
        self.exclusions_folders_name = exclusions.get('folders_name', [])
        self.exclusions_file_ext = exclusions.get('file_extensions', [])
        self.service = service

    def on_created(self, event):
        """
        Handle file creation events. 
        """
        if not event.is_directory:
            self._analyze(event.src_path)

    def on_modified(self, event):
        """
        Handle file modification events.
        """
        if not event.is_directory:
            self._analyze(event.src_path)
 
    def _analyze(self, file_path):
        try:
            if any(file_path.startswith(folder) for folder in self.exclusions_folder):
                self._log(f"File {file_path} ignored due to exclusion folder", "IGNORED")
                return
            if any(name in file_path for name in self.exclusions_folders_name):
                self._log(f"File {file_path} ignored due to exclusion folder name", "IGNORED")
                return
            file_ext = os.path.splitext(file_path.lower())[1].lstrip('.')
            print(f"File extension: {file_ext}")
            if file_ext in self.exclusions_file_ext:
                self._log(f"File {file_path} is in the exclusion list for file extensions.", "IGNORED")
                return 
            #self.service.submit_file_analysis(file_path)  # Use adapter
            trio.run(self.service.analyze_file, file_path)  # Use adapter
        except Exception as e:
            self._log(f"Watching file {file_path}: {str(e)}", "ERROR")


class MonitorMalwareService(win32serviceutil.ServiceFramework):
    """Windows service for monitoring macro malware in Office files."""
    
    _svc_name_ = "A_Monitor_Macro_Malware_Service"
    _svc_display_name_ = "A Monitor Macro Malware Service"
    _svc_description_ = "Monitors macro-based malware in Microsoft Office files"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        
        # Script directory for logs and Sysinternals
        
        self.log_dir = os.path.join(current_dir, f"Logs/Logs_{timestamp}")
        os.makedirs(self.log_dir, exist_ok=True)

        self.log_file = os.path.join(self.log_dir, f"logs_")
        self.log_sniffer_file = os.path.join(self.log_dir, f"logsniffer_{timestamp}.txt")
        self.pcap_file = os.path.join(self.log_dir, f"network_{timestamp}.pcap")
        
        self.monitor_dir = "C:\\"


        self.blacklist = Blacklist(self.log_dir, self._log)
        self.watchlist = Watchlist(self.log_dir, self._log)

        # Initialize Sysinternals and modules
        self.sysinternals_path = os.path.join(current_dir, 'SYSINTERNAL')
        self.analyzer = Analyzer(self.sysinternals_path, self.log_dir, self.blacklist, self.watchlist, self._log)

        # Initialize file system observer
        self.observer = Observer()
        self.event_handler = MalwareFileHandler(self._log, self.blacklist.exclusions,self.analyzer)
        self.observer.schedule(self.event_handler, path=self.monitor_dir, recursive=True)

        # Network sniffing thread
        self.sniffing_thread = None

        # Task queue for Trio tasks
        self.task_queue = queue.Queue()
        self.trio_thread = threading.Thread(target=self._run_trio_loop, daemon=True)
        self.trio_thread.start()

    def _run_trio_loop(self):
        trio.run(self._trio_main)

    async def _trio_main(self):
        async with trio.open_nursery() as nursery:
            nursery.start_soon(self._process_tasks)
            await trio.sleep_forever()

    async def _process_tasks(self):
        while self.is_running:
            try:
                task, args = self.task_queue.get_nowait()
                await task(*args)
                self.task_queue.task_done()
            except queue.Empty:
                await trio.sleep(0.01)

    def submit_file_analysis(self, file_path):
        """Adapter for analyze_file."""
        self.task_queue.put((self.analyzer.analyze_file, (file_path,)))

    def submit_process_analysis(self, pid):
        """Adapter for analyze_process."""
        self.task_queue.put((self.analyzer.analyze_process, (pid,)))

    def SvcStop(self):
        """Stop the service, observer, and network sniffing."""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.observer.stop()
        self.observer.join()

        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        self._log("Service stopped", "INFO", force=True)
        
        # Save the blacklist and watchlist to JSON files
        self.blacklist.save_to_json(force=True)
        self.watchlist.save_to_json(force=True)

        if self.sniffing_thread:
            self.sniffing_thread.join(timeout=5.0)

        if self.trio_thread:
            self.trio_thread.join(timeout=5.0)


    def SvcDoRun(self):
        """Start the service, Sysmon, observer, and network sniffing."""
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,
                            servicemanager.PYS_SERVICE_STARTED,
                            (self._svc_name_, ''))
        self._log("Service started", "INFO")
        # Start file system observer
        self.observer.start()

        # Start network sniffing
        self.sniffing_thread = threading.Thread(target=self.sniff_network, daemon=True)
        self.sniffing_thread.start()
        
        # Start process lifecycle monitoring
        self.monitor_process_lifecycle()
        # Run infinite loop to keep the service running
        self.main()

    def main(self):
        while self.is_running:
            time.sleep(1)


    def _log(self, message, severity="INFO", force = False):

        """Log messages to the log file and queue for later processing."""
        if severity in ["IGNORED", "BM"]:
            return
        tag = f"[{severity}]"
        log_message = f"[{time.ctime()}]{tag} {message}"
        try:
            with open(self.log_file + "FULL.log", "a") as f:
                f.write(f"{log_message}\n")

            with open(self.log_file + f"_{severity}.log", "a") as f:
                f.write(f"{log_message}\n")
        except Exception as e:
            servicemanager.LogErrorMsg(f"[_log] Logging failed: {str(e)}")

    def monitor_process_lifecycle(self):
        """Monitor process creation and termination using WMI."""
        self._log("Starting process lifecycle monitoring...", "INFO")
        wmi_client = wmi.WMI()
        process_watcher = wmi_client.Win32_Process.watch_for("creation")
        try:
            while self.is_running:
                new_process = process_watcher()
                pid = new_process.ProcessId
                name = new_process.Name
                if name.lower() in self.blacklist.exclusions.get('processes', []):
                    #self._log(f"Process {name} (PID: {pid}) is in the exclusion list, skipping analysis.", "IGNORED")
                    continue
                trio.run(self.analyzer.analyze_process,pid)  # Use adapter
                time.sleep(.1)  # Give the process a moment to initialize

        except Exception as e:
            self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")

    def sniff_network(self):
        """Sniff network packets for Office-related suspicious activities."""
        try:
            self._log("Starting network packet sniffing...", "INFO")
            sniff(prn=self.analyzer.analyze_packet, filter="tcp or udp", store=False, iface="Ethernet1")
        except Exception as e:
            self._log(f"Network sniffing error: {str(e)}", "ERROR")

if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(MonitorMalwareService)
            servicemanager.StartServiceCtrlDispatcher()
        else:
            win32serviceutil.HandleCommandLine(MonitorMalwareService)
    except Exception as e:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        error_log = os.path.join(script_dir, f"error_{timestamp}.txt")
        with open(error_log, "a") as f:
            f.write(f"[{time.ctime()}] Error: {str(e)}\n")