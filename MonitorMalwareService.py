import win32serviceutil
import win32service
import win32event
import servicemanager
import sys
import time
import os
from datetime import datetime
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scapy.all import sniff, wrpcap
from scapy.main import load_layer
load_layer("tls")

from modules.analyzer import Analyzer
import psutil
import wmi  # For process lifecycle monitoring
import trio
import queue
import logging
from logging import Filter, FileHandler
from modules.blacklist import Blacklist
from modules.watchlist import Watchlist
import traceback
import pythoncom

current_dir = os.path.dirname(os.path.abspath(__file__))
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
# Custom filter for severity-specific log files
class SeverityFilter(Filter):
    def __init__(self, severity):
        super().__init__()
        self.severity = severity

    def filter(self, record):
        return record.levelname == self.severity

class MalwareFileHandler(FileSystemEventHandler):
    """Activate when a file is created or modified in the monitored directory."""
    def __init__(self, log_func, exclusions, service):
        self._log = log_func
        self.exclusions_folder = exclusions.get('folders', [])
        self.exclusions_folders_name = exclusions.get('folders_name', [])
        self.exclusions_file_ext = exclusions.get('file_extensions', [])
        self.service = service

    def on_created(self, event):
        """
        Handle file creation events. 
        """
        if not event.is_directory:
            self._analyze(event.src_path)

    def on_modified(self, event):
        """
        Handle file modification events.
        """
        if not event.is_directory:
            self._analyze(event.src_path)
 
    def _analyze(self, file_path):
        try:
            if any(file_path.startswith(folder) for folder in self.exclusions_folder):
                self._log(f"File {file_path} ignored due to exclusion folder", "IGNORED")
                return
            if any(name in file_path for name in self.exclusions_folders_name):
                self._log(f"File {file_path} ignored due to exclusion folder name", "IGNORED")
                return
            file_ext = os.path.splitext(file_path.lower())[1].lstrip('.')
            print(f"File extension: {file_ext}")
            if file_ext in self.exclusions_file_ext:
                self._log(f"File {file_path} is in the exclusion list for file extensions.", "IGNORED")
                return 
            #self.service.submit_file_analysis(file_path)  # Use adapter
            trio.run(self.service.analyze_file, file_path)  # Use adapter
        except Exception as e:
            self._log(f"Watching file {file_path}: {str(e)}", "ERROR")


class MonitorMalwareService(win32serviceutil.ServiceFramework):
    """Windows service for monitoring macro malware in Office files."""
    
    _svc_name_ = "A_Monitor_Macro_Malware_Service"
    _svc_display_name_ = "A Monitor Macro Malware Service"
    _svc_description_ = "Monitors macro-based malware in Microsoft Office files"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        
        # Script directory for logs and Sysinternals
        
        self.log_dir = os.path.join(current_dir, f"Logs/Logs_{timestamp}")
        os.makedirs(self.log_dir, exist_ok=True)

        self.log_file = os.path.join(self.log_dir, f"logs_")
        self.log_sniffer_file = os.path.join(self.log_dir, f"logsniffer_{timestamp}.txt")
        self.pcap_file = os.path.join(self.log_dir, f"network_{timestamp}.pcap")
        
        #  # Configure logging
        # self.logger = logging.getLogger('MonitorMalwareService')
        # self.logger.setLevel(logging.INFO)
        # log_format = logging.Formatter('[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%a %b %d %H:%M:%S %Y')

        # # Full log handler (all severities)
        # full_handler = FileHandler(os.path.join(self.log_dir, 'logs_FULL.log'), encoding='utf-8')
        # full_handler.setFormatter(log_format)
        # self.logger.addHandler(full_handler)

        # # INFO log handler
        # info_handler = FileHandler(os.path.join(self.log_dir, 'logs_INFO.log'), encoding='utf-8')
        # info_handler.setLevel(logging.INFO)
        # info_handler.addFilter(SeverityFilter('INFO'))
        # info_handler.setFormatter(log_format)
        # self.logger.addHandler(info_handler)

        # # WARN log handler
        # warn_handler = FileHandler(os.path.join(self.log_dir, 'logs_WARN.log'), encoding='utf-8')
        # warn_handler.setLevel(logging.WARNING)
        # warn_handler.addFilter(SeverityFilter('WARNING'))
        # warn_handler.setFormatter(log_format)
        # self.logger.addHandler(warn_handler)

        # # CRITICAL log handler
        # critical_handler = FileHandler(os.path.join(self.log_dir, 'logs_CRITICAL.log'), encoding='utf-8')
        # critical_handler.setLevel(logging.CRITICAL)
        # critical_handler.addFilter(SeverityFilter('CRITICAL'))
        # critical_handler.setFormatter(log_format)
        # self.logger.addHandler(critical_handler)

        # # ERROR log handler
        # error_handler = FileHandler(os.path.join(self.log_dir, 'logs_ERROR.log'), encoding='utf-8')
        # error_handler.setLevel(logging.ERROR)
        # error_handler.addFilter(SeverityFilter('ERROR'))
        # error_handler.setFormatter(log_format)
        # self.logger.addHandler(error_handler)

        # Directory to monitor (limited to user Documents for performance)
        self.monitor_dir = "C:\\"


        self.blacklist = Blacklist(self.log_dir, self._log)
        self.watchlist = Watchlist(self.log_dir, self._log)


        # Initialize Sysinternals and modules
        self.sysinternals_path = os.path.join(current_dir, 'SYSINTERNAL')
        self.analyzer = Analyzer(self.sysinternals_path, self.log_dir, self.blacklist, self.watchlist, self._log)

        # Initialize file system observer
        self.observer = Observer()
        self.event_handler = MalwareFileHandler(self._log, self.blacklist.exclusions,self.analyzer)
        self.observer.schedule(self.event_handler, path=self.monitor_dir, recursive=True)

        # Network sniffing thread
        self.sniffing_thread = None

        # Task queue for Trio tasks
        self.task_queue = queue.Queue()
        self.trio_thread = threading.Thread(target=self._run_trio_loop, daemon=True)
        self.trio_thread.start()

    def _run_trio_loop(self):
        trio.run(self._trio_main)

    async def _trio_main(self):
        async with trio.open_nursery() as nursery:
            nursery.start_soon(self._process_tasks)
            await trio.sleep_forever()

    async def _process_tasks(self):
        while self.is_running:
            try:
                task, args = self.task_queue.get_nowait()
                await task(*args)
                self.task_queue.task_done()
            except queue.Empty:
                await trio.sleep(0.01)

    def submit_file_analysis(self, file_path):
        """Adapter for analyze_file."""
        self.task_queue.put((self.analyzer.analyze_file, (file_path,)))

    def submit_process_analysis(self, pid):
        """Adapter for analyze_process."""
        self.task_queue.put((self.analyzer.analyze_process, (pid,)))

    def SvcStop(self):
        """Stop the service, observer, and network sniffing."""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)

        self.observer.stop()
        self.observer.join()

        win32event.SetEvent(self.hWaitStop)
        self.is_running = False
        self._log("Service stopped", "INFO", force=True)
        
        # Save the blacklist and watchlist to JSON files
        self.blacklist.save_to_json(force=True)
        self.watchlist.save_to_json(force=True)

        if self.sniffing_thread:
            self.sniffing_thread.join(timeout=5.0)

        if self.trio_thread:
            self.trio_thread.join(timeout=5.0)


    def SvcDoRun(self):
        """Start the service, Sysmon, observer, and network sniffing."""
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,
                            servicemanager.PYS_SERVICE_STARTED,
                            (self._svc_name_, ''))
        self._log("Service started", "INFO")
        # Start file system observer
        self.observer.start()

        # Start network sniffing
        self.sniffing_thread = threading.Thread(target=self.sniff_network, daemon=True)
        self.sniffing_thread.start()
        
        # Start process lifecycle monitoring
        self.monitor_process_lifecycle()
        # Run infinite loop to keep the service running
        self.main()

    def main(self):
        # # Create threads for concurrent execution
        # #  dir_thread = threading.Thread(target=self.scan_directory)
        # proc_thread = threading.Thread(target=self.scan_processes)

        # # Start threads
        # # dir_thread.start()
        # proc_thread.start()

        # # Optionally join them if you want to wait for completion (one-time scan)
        # # dir_thread.join()
        while self.is_running:
            time.sleep(1)
        #proc_thread.join()

    def _log(self, message, severity="INFO", force = False):

        """Log messages to the log file and queue for later processing."""
        if severity in ["IGNORED", "BM"]:
            return
        tag = f"[{severity}]"
        log_message = f"[{time.ctime()}]{tag} {message}"
        try:
            with open(self.log_file + "FULL.log", "a") as f:
                f.write(f"{log_message}\n")

            with open(self.log_file + f"_{severity}.log", "a") as f:
                f.write(f"{log_message}\n")
        except Exception as e:
            servicemanager.LogErrorMsg(f"[_log] Logging failed: {str(e)}")

    # Background thread function to process log messages
    # def _log(self, message, severity="INFO", force=False):
    #     if severity in ["IGNORED" , "BM"] and not force:
    #         return
    #     # Map custom severity to logging levels
    #     level_map = {
    #         "INFO": logging.INFO,
    #         "WARN": logging.WARNING,
    #         "ALERT": logging.WARNING,  # Use WARNING for ALERT
    #         "CRITICAL": logging.CRITICAL,
    #         "ERROR": logging.ERROR
    #     }
    #     log_level = level_map.get(severity, logging.INFO) 
    #     self.logger.log(log_level, message)


    # def scan_directory(self):
    #     """Scan the monitored directory for existing Office files and analyze them.

    #     """
    #     self._log(f"Scanning directory {self.monitor_dir} for Office files", "INFO")
    #     excluded_folders = set(self.blacklist.exclusions.get('folders', [])) 
    #     excluded_folders_name = set(self.blacklist.exclusions.get('folders_name', []))
    #     # Traverse the directory tree
    #     for root, dirs, files in os.walk(self.monitor_dir, topdown=True):
    #         # Normalize the current root path
    #         norm_root = os.path.normpath(root)

    #         # Check if the current root should be excluded
    #         if (any(norm_root.startswith(excluded) for excluded in excluded_folders) or
    #             os.path.basename(norm_root) in excluded_folders_name):
    #             self._log(f"Skipping excluded directory: {norm_root}","WARN")
    #             dirs[:] = []  # Prevent traversing into subdirectories
    #             continue  # Skip adding this root

    #         # If not excluded, scan
    #         for file in files:
    #             file_path = os.path.join(str(norm_root),file)
    #             self.submit_file_analysis(file_path)  # Use adapter
    #         # Filter out subdirectories whose names are in excluded_folders_name
    #         dirs[:] = [d for d in dirs if d not in excluded_folders_name]

    # def monitor_process_lifecycle(self):
    #     """Monitor process creation and termination using WMI."""
    #     process_watcher = self.wmi_client.Win32_Process.watch_for("creation")
    #     while self.is_running:
    #         time.sleep(1)  # Adjust the sleep time as needed
    #         self._log("Monitoring process lifecycle...", "INFO")
    #         try:
    #             new_process = process_watcher()
    #             self._log(f"New process created: {new_process.Name} (PID: {new_process.ProcessId})", "INFO")
    #             #self.submit_process_analysis(new_process.ProcessId)  # Use adapter
    #         except Exception as e:
    #             self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")



    def monitor_process_lifecycle(self):
        """Monitor process creation and termination using WMI."""
        self._log("Starting process lifecycle monitoring...", "INFO")
        wmi_client = wmi.WMI()
        process_watcher = wmi_client.Win32_Process.watch_for("creation")
        try:
            while self.is_running:
                new_process = process_watcher()
                pid = new_process.ProcessId
                name = new_process.Name
                if name.lower() in self.blacklist.exclusions.get('processes', []):
                    #self._log(f"Process {name} (PID: {pid}) is in the exclusion list, skipping analysis.", "IGNORED")
                    continue
                # Submit the process for analysis
                #self.submit_process_analysis(pid)
                trio.run(self.analyzer.analyze_process,pid)  # Use adapter
                time.sleep(.1)  # Give the process a moment to initialize

        except Exception as e:
            self._log(f"Error in process lifecycle monitoring: {str(e)}", "ERROR")

    # def scan_processes(self):
    #     """Monitor running processes for suspicious activities, including background processes and common Windows apps."""
    #     while self.is_running:
    #         self._log(f"Scanning processes for suspicious", "INFO")
    #         proc_cache = list(psutil.process_iter(['pid']))
    #         for proc in proc_cache:
    #             self.submit_process_analysis(proc.pid)  # Use adapter
    #         time.sleep(5)  # Adjust the sleep time as needed


    def sniff_network(self):
        """Sniff network packets for Office-related suspicious activities."""
        try:
            self._log("Starting network packet sniffing...", "INFO")
            sniff(prn=self.analyzer.analyze_packet, filter="tcp or udp", store=False, iface="Ethernet1")
        except Exception as e:
            self._log(f"Network sniffing error: {str(e)}", "ERROR")

if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(MonitorMalwareService)
            servicemanager.StartServiceCtrlDispatcher()
        else:
            win32serviceutil.HandleCommandLine(MonitorMalwareService)
    except Exception as e:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        error_log = os.path.join(script_dir, f"error_{timestamp}.txt")
        with open(error_log, "a") as f:
            f.write(f"[{time.ctime()}] Error: {str(e)}\n")